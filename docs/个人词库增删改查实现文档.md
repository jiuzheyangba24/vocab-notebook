# 个人词库增删改查 - 前后端数据库完整实现文档

> 本文档详细解释前端、后端、数据库三者的代码，以及它们是如何连接的。

---

## 一、整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         用户浏览器                               │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  前端 (Vue 3)                                                    │
│  文件: frontend/src/stores/vocabulary.js                        │
│  功能: 管理单词列表状态、调用API                                  │
└─────────────────────────────────────────────────────────────────┘
                                │
                                │  HTTP 请求 (通过 Axios)
                                │  文件: frontend/src/composables/useApi.js
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  后端 (Spring Boot)                                              │
│  文件: backend/src/main/java/com/vocab/controller/WordController.java
│  功能: 接收请求、处理业务逻辑、操作数据库                          │
└─────────────────────────────────────────────────────────────────┘
                                │
                                │  JPA (Java 持久化 API)
                                │  文件: backend/src/main/java/com/vocab/repository/WordRepository.java
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  数据库 (MySQL)                                                  │
│  文件: database/schema.sql                                       │
│  表名: words                                                     │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、三者如何连接

### 2.1 前端 → 后端（HTTP 请求）

**连接文件**: `frontend/src/composables/useApi.js`

```javascript
// 第 1-7 行：创建 Axios 实例，配置基础路径
import axios from 'axios'

const api = axios.create({
    baseURL: '/api',    // 所有请求都会加上 /api 前缀
    timeout: 10000      // 超时时间 10 秒
})

// 第 66-72 行：定义单词相关的 API 方法
export const wordsApi = {
    getAll: () => api.get('/words'),           // 查询：GET /api/words
    add: (word) => api.post('/words', word),   // 新增：POST /api/words
    delete: (id) => api.delete(`/words/${id}`) // 删除：DELETE /api/words/{id}
}
```

**连接原理**: 
- 前端使用 `Axios` 库发送 HTTP 请求
- 请求地址以 `/api` 开头
- Vite 开发服务器配置了代理，把 `/api` 开头的请求转发到后端 `localhost:3000`

**代理配置**: `frontend/vite.config.js` 第 77-82 行
```javascript
server: {
    port: 5173,
    proxy: {
        '/api': {
            target: 'http://localhost:3000',  // 转发到后端
            changeOrigin: true
        }
    }
}
```

---

### 2.2 后端 → 数据库（JPA）

**连接配置**: `backend/src/main/resources/application.properties`

```properties
# 数据库连接
spring.datasource.url=jdbc:mysql://localhost:3306/vocab_notebook
spring.datasource.username=root
spring.datasource.password=你的密码

# JPA 配置
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

**Repository 接口**: `backend/src/main/java/com/vocab/repository/WordRepository.java`

```java
public interface WordRepository extends JpaRepository<Word, Long> {
    // JPA 会根据方法名自动生成 SQL
    List<Word> findByUserIdAndIsDeletedFalseOrderByCreatedAtDesc(Long userId);
    
    // 软删除方法
    @Modifying
    @Query("UPDATE Word w SET w.isDeleted = true WHERE w.wordId = ?1 AND w.userId = ?2")
    int softDelete(Long wordId, Long userId);
}
```

---

## 三、增删改查详细代码

### 3.1 查询（Read）- 获取单词列表

#### 【数据库】words 表结构
**文件**: `database/schema.sql` 第 36-60 行

```sql
CREATE TABLE words (
    word_id INT PRIMARY KEY AUTO_INCREMENT,  -- 主键
    user_id INT NOT NULL,                    -- 用户ID
    word VARCHAR(100) NOT NULL,              -- 单词
    translation TEXT NOT NULL,               -- 翻译
    phonetic VARCHAR(100),                   -- 音标
    mastery_level INT DEFAULT 0,             -- 掌握度
    is_deleted BOOLEAN DEFAULT FALSE,        -- 软删除标记
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 【后端】接收请求，查询数据库
**文件**: `backend/src/main/java/com/vocab/controller/WordController.java` 第 45-70 行

```java
@GetMapping                    // 处理 GET /api/words 请求
public ResponseEntity<?> getWords(@AuthenticationPrincipal JwtUserPrincipal principal) {
    // 1. 获取当前登录用户的ID
    Long userId = getCurrentUserId(principal);
    
    // 2. 调用 Repository 查询数据库
    List<Word> words = wordRepository.findByUserIdAndIsDeletedFalseOrderByCreatedAtDesc(userId);
    
    // 3. 转换成前端需要的 JSON 格式
    List<Map<String, Object>> result = words.stream().map(word -> {
        Map<String, Object> map = new HashMap<>();
        map.put("id", word.getWordId());
        map.put("headWord", word.getWord());
        map.put("definition", word.getTranslation());
        return map;
    }).collect(Collectors.toList());
    
    // 4. 返回 JSON 数据给前端
    return ResponseEntity.ok(result);
}
```

#### 【前端】发送请求，接收数据
**文件**: `frontend/src/stores/vocabulary.js` 第 106-130 行

```javascript
async function loadVocabulary() {
    isLoading.value = true
    try {
        if (isLoggedIn()) {
            // 调用 API 获取数据
            const dbWords = await wordsApi.getAll()  // 发送 GET /api/words
            vocabulary.value = dbWords || []
        }
    } finally {
        isLoading.value = false
    }
}
```

#### 查询流程图
```
用户打开页面
    ↓
前端调用 wordsApi.getAll()
    ↓
发送 GET /api/words 请求
    ↓
后端 WordController.getWords() 接收
    ↓
调用 wordRepository.findByUserIdAndIsDeletedFalse()
    ↓
JPA 生成 SQL: SELECT * FROM words WHERE user_id=? AND is_deleted=false
    ↓
MySQL 执行查询，返回数据
    ↓
后端转换成 JSON 返回
    ↓
前端接收，存入 vocabulary 数组
    ↓
Vue 自动更新页面显示
```

---

### 3.2 新增（Create）- 添加单词

#### 【前端】发送添加请求
**文件**: `frontend/src/stores/vocabulary.js` 第 209-239 行

```javascript
async function addWord(word) {
    // 1. 检查单词是否已存在（前端先校验）
    const exists = vocabulary.value.some(
        w => w.headWord.toLowerCase() === word.headWord.toLowerCase()
    )
    if (exists) {
        throw new Error('该单词已存在')
    }

    // 2. 发送 POST 请求到后端
    const newWord = await wordsApi.add(word)  // POST /api/words
    
    // 3. 把返回的新单词添加到本地列表
    vocabulary.value.push(newWord)
}
```

#### 【后端】处理添加请求
**文件**: `backend/src/main/java/com/vocab/controller/WordController.java` 第 75-105 行

```java
@PostMapping                   // 处理 POST /api/words 请求
public ResponseEntity<?> addWord(@RequestBody AddWordRequest request) {
    Long userId = getCurrentUserId(principal);

    // 1. 检查单词是否已存在（后端再校验）
    if (wordRepository.findByUserIdAndWordAndIsDeletedFalse(userId, request.getHeadWord()).isPresent()) {
        return ResponseEntity.badRequest().body(Map.of("error", "该单词已存在"));
    }

    // 2. 创建实体对象
    Word word = new Word();
    word.setUserId(userId);
    word.setWord(request.getHeadWord());
    word.setTranslation(request.getDefinition());
    word.setPhonetic(request.getPronunciation());

    // 3. 保存到数据库（JPA 自动生成 INSERT 语句）
    word = wordRepository.save(word);

    // 4. 返回新创建的单词给前端
    return ResponseEntity.ok(result);
}
```

#### 【数据库】实际执行的 SQL
```sql
INSERT INTO words (user_id, word, translation, phonetic, created_at) 
VALUES (1, 'apple', '苹果', '/ˈæp.əl/', NOW());
```

---

### 3.3 删除（Delete）- 删除单词

#### 【前端】发送删除请求
**文件**: `frontend/src/stores/vocabulary.js` 第 246-274 行

```javascript
async function deleteWord() {
    const wordToDelete = vocabulary.value[currentIndex.value]

    // 1. 发送 DELETE 请求到后端
    await wordsApi.delete(wordToDelete.id)  // DELETE /api/words/{id}

    // 2. 从本地列表移除
    vocabulary.value.splice(currentIndex.value, 1)
}
```

#### 【后端】处理删除请求（软删除）
**文件**: `backend/src/main/java/com/vocab/controller/WordController.java` 第 110-122 行

```java
@DeleteMapping("/{id}")        // 处理 DELETE /api/words/{id} 请求
@Transactional
public ResponseEntity<?> deleteWord(@PathVariable Long id) {
    Long userId = getCurrentUserId(principal);

    // 软删除：只更新 is_deleted 字段，不真正删除数据
    int affected = wordRepository.softDelete(id, userId);
    
    if (affected == 0) {
        return ResponseEntity.notFound().build();
    }

    return ResponseEntity.ok(Map.of("message", "单词删除成功"));
}
```

#### 【数据库】实际执行的 SQL（软删除）
```sql
-- 软删除：不是真的删除，只是标记
UPDATE words SET is_deleted = TRUE WHERE word_id = 123 AND user_id = 1;

-- 查询时自动过滤已删除的数据
SELECT * FROM words WHERE user_id = 1 AND is_deleted = FALSE;
```

---

## 四、文件位置汇总

| 层级 | 文件路径 | 功能 | 关键行号 |
|------|---------|------|---------|
| **前端-状态管理** | `frontend/src/stores/vocabulary.js` | 管理单词列表 | 106-274 |
| **前端-API封装** | `frontend/src/composables/useApi.js` | 发送HTTP请求 | 66-72 |
| **前端-代理配置** | `frontend/vite.config.js` | 转发请求到后端 | 77-82 |
| **后端-控制器** | `backend/src/.../WordController.java` | 处理API请求 | 45-122 |
| **后端-仓库** | `backend/src/.../WordRepository.java` | 操作数据库 | - |
| **后端-实体** | `backend/src/.../entity/Word.java` | 数据模型 | - |
| **数据库-表结构** | `database/schema.sql` | 定义表结构 | 36-60 |

---

## 五、通俗理解（答辩用）

> "个人词库的增删改查是这样实现的：
> 
> **前端**用 Vue 3 框架，单词数据存在 Pinia Store 里（vocabulary.js），用户操作时调用 useApi.js 里封装好的 API 方法，比如 `wordsApi.add()` 添加、`wordsApi.delete()` 删除。
> 
> **前端和后端怎么连接？** 用 Axios 库发 HTTP 请求，Vite 配置了代理，把 `/api` 开头的请求转发到后端 3000 端口。
> 
> **后端**用 Spring Boot 框架，WordController 里用 `@GetMapping`、`@PostMapping`、`@DeleteMapping` 注解定义接口。Controller 调用 Repository 操作数据库。
> 
> **后端和数据库怎么连接？** 用 JPA（Java 持久化 API），只要定义好 Repository 接口，JPA 会自动生成 SQL 语句。
> 
> **数据库**用 MySQL，words 表存储单词数据。删除用软删除，只把 is_deleted 字段标记为 true，数据还在。"

---

## 六、常见答辩问题

| 问题 | 回答 |
|------|------|
| 前端怎么调后端？ | 用 Axios 发 HTTP 请求，配置了代理转发 |
| 后端怎么连数据库？ | 用 JPA，在 application.properties 配置连接信息 |
| 为什么用软删除？ | 防止误删，数据可恢复，也方便做统计 |
| @GetMapping 是什么？ | Spring Boot 注解，表示这个方法处理 GET 请求 |
| wordsApi.add() 发什么请求？ | POST 请求，请求地址是 /api/words |
